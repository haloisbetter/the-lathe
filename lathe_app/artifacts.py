"""
Lathe App Artifacts

Plain data objects representing execution results.
These are the "nouns" of the app layer.
"""
import uuid
from dataclasses import dataclass, field
from datetime import datetime, timezone
from typing import Any, Dict, List, Optional


def _generate_id() -> str:
    """Generate a unique artifact ID."""
    return str(uuid.uuid4())


def _now() -> str:
    """Generate ISO timestamp."""
    return datetime.now(timezone.utc).isoformat()


@dataclass
class ArtifactInput:
    """The input that produced an artifact."""
    intent: str
    task: str
    why: Dict[str, Any]
    model_requested: Optional[str] = None
    workspace_id: Optional[str] = None


@dataclass
class ObservabilityTrace:
    """Observability data from pipeline execution."""
    trace_id: str
    stages: List[Dict[str, Any]]
    models: Dict[str, Any]
    outcome: Dict[str, Any]
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ObservabilityTrace":
        """Create from pipeline _observability block."""
        return cls(
            trace_id=data.get("trace_id", ""),
            stages=data.get("stages", []),
            models=data.get("models", {}),
            outcome=data.get("outcome", {}),
        )
    
    @classmethod
    def empty(cls) -> "ObservabilityTrace":
        """Create an empty trace."""
        return cls(trace_id="", stages=[], models={}, outcome={})


@dataclass
class RefusalArtifact:
    """
    Represents a refusal from Lathe.
    
    A refusal is NOT a failure - it's a valid outcome
    indicating the request could not be fulfilled.
    """
    id: str
    timestamp: str
    input: ArtifactInput
    reason: str
    details: str
    observability: ObservabilityTrace
    
    @classmethod
    def create(
        cls,
        input_data: ArtifactInput,
        reason: str,
        details: str,
        observability: ObservabilityTrace,
    ) -> "RefusalArtifact":
        return cls(
            id=_generate_id(),
            timestamp=_now(),
            input=input_data,
            reason=reason,
            details=details,
            observability=observability,
        )


@dataclass
class ProposalArtifact:
    """
    Represents a successful proposal from Lathe.
    
    Contains the proposals, assumptions, and risks
    generated by the model.
    """
    id: str
    timestamp: str
    input: ArtifactInput
    proposals: List[Dict[str, Any]]
    assumptions: List[str]
    risks: List[str]
    results: List[Any]
    model_fingerprint: Optional[str]
    observability: ObservabilityTrace
    
    @classmethod
    def create(
        cls,
        input_data: ArtifactInput,
        proposals: List[Dict[str, Any]],
        assumptions: List[str],
        risks: List[str],
        results: List[Any],
        model_fingerprint: Optional[str],
        observability: ObservabilityTrace,
    ) -> "ProposalArtifact":
        return cls(
            id=_generate_id(),
            timestamp=_now(),
            input=input_data,
            proposals=proposals,
            assumptions=assumptions,
            risks=risks,
            results=results,
            model_fingerprint=model_fingerprint,
            observability=observability,
        )


@dataclass
class PlanArtifact:
    """
    Represents a plan generated by Lathe.
    
    Plans are structured sequences of steps
    that can be executed or reviewed.
    """
    id: str
    timestamp: str
    input: ArtifactInput
    steps: List[Dict[str, Any]]
    dependencies: List[str]
    results: List[Any]
    model_fingerprint: Optional[str]
    observability: ObservabilityTrace
    
    @classmethod
    def create(
        cls,
        input_data: ArtifactInput,
        steps: List[Dict[str, Any]],
        dependencies: List[str],
        results: List[Any],
        model_fingerprint: Optional[str],
        observability: ObservabilityTrace,
    ) -> "PlanArtifact":
        return cls(
            id=_generate_id(),
            timestamp=_now(),
            input=input_data,
            steps=steps,
            dependencies=dependencies,
            results=results,
            model_fingerprint=model_fingerprint,
            observability=observability,
        )


@dataclass
class ToolCallTrace:
    """
    Immutable record of a single tool execution.

    Appended to RunRecord.tool_calls after each tool phase.
    Full raw output is stored internally; only summaries appear
    in the trace visible to agents and the TUI.
    """
    tool_id: str
    timestamp: str
    inputs: Dict[str, Any]
    result_summary: Dict[str, Any]
    status: str  # "success" | "refused" | "error"
    raw_result: Optional[Dict[str, Any]] = None
    refusal_reason: Optional[str] = None

    @classmethod
    def create(
        cls,
        tool_id: str,
        inputs: Dict[str, Any],
        result_summary: Dict[str, Any],
        status: str,
        raw_result: Optional[Dict[str, Any]] = None,
        refusal_reason: Optional[str] = None,
    ) -> "ToolCallTrace":
        return cls(
            tool_id=tool_id,
            timestamp=_now(),
            inputs=inputs,
            result_summary=result_summary,
            status=status,
            raw_result=raw_result,
            refusal_reason=refusal_reason,
        )

    def to_trace_dict(self) -> Dict[str, Any]:
        d: Dict[str, Any] = {
            "tool_id": self.tool_id,
            "timestamp": self.timestamp,
            "inputs": self.inputs,
            "result_summary": self.result_summary,
            "status": self.status,
        }
        if self.refusal_reason is not None:
            d["refusal_reason"] = self.refusal_reason
        return d


@dataclass
class RunRecord:
    """
    Complete record of a single orchestrator execution.
    
    This is the top-level artifact returned by run_request().
    Contains the input, output artifact, and execution metadata.
    """
    id: str
    timestamp: str
    input: ArtifactInput
    output: Any  # RefusalArtifact | ProposalArtifact | PlanArtifact
    model_used: str
    fallback_triggered: bool
    success: bool
    classification: Any = None  # ResultClassification
    escalation: Optional[Dict[str, Any]] = None
    file_reads: List[Dict[str, Any]] = field(default_factory=list)
    workspace_context_loaded: Optional[Dict[str, Any]] = None
    tool_calls: List[ToolCallTrace] = field(default_factory=list)
    
    @classmethod
    def create(
        cls,
        input_data: ArtifactInput,
        output: Any,
        model_used: str,
        fallback_triggered: bool,
        success: bool,
        classification: Any = None,
        escalation: Optional[Dict[str, Any]] = None,
        file_reads: Optional[List[Dict[str, Any]]] = None,
        workspace_context_loaded: Optional[Dict[str, Any]] = None,
        tool_calls: Optional[List["ToolCallTrace"]] = None,
    ) -> "RunRecord":
        return cls(
            id=_generate_id(),
            timestamp=_now(),
            input=input_data,
            output=output,
            model_used=model_used,
            fallback_triggered=fallback_triggered,
            success=success,
            classification=classification,
            escalation=escalation,
            file_reads=file_reads or [],
            workspace_context_loaded=workspace_context_loaded,
            tool_calls=tool_calls or [],
        )
