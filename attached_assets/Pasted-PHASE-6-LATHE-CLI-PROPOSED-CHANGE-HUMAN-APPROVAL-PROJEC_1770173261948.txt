PHASE 6 â€” LATHE CLI: PROPOSED CHANGE + HUMAN APPROVAL

PROJECT CONTEXT
- Python CLI project
- Python 3.11+
- No frontend
- No web server
- No HTTP APIs
- WHY engine implemented and enforced
- Folder context ledger auto-updates
- Safe command execution implemented
- Controlled patch application implemented
- Filesystem-only repo awareness implemented
- Deterministic context retrieval implemented
- Agent-side RAG implemented (filesystem-first)
- Model reasoning layer implemented (reasoning-only)
- lathe.yml is the primary configuration file
- Deployment environment MAY auto-create a production database
- Any database MUST be ignored completely

ABSOLUTE CONSTRAINTS (NON-NEGOTIABLE)
- Do NOT use any database of any kind.
- Do NOT persist embeddings or indexes.
- Do NOT allow models to execute commands.
- Do NOT allow models to write files directly.
- Filesystem + CLI remain the only authority.
- Models may ONLY propose changes, never apply them.

GLOBAL CONSTRAINTS
- Use ASCII only.
- Create full, drop-in files only.
- Do not refactor unrelated code.
- If uncertain, STOP and explain assumptions.
- Do not exceed 10 seconds of reasoning per step.
- Only complete TWO steps total, then STOP.

OPERATING RULES
- Produce a short PLAN first (max 6 steps).
- Mark each step as: safe / risky / destructive.
- Execute ONLY Step 1 and Step 2.
- After Step 2, STOP and wait.

GOAL
Allow Lathe to propose concrete code changes as patches,
while preserving full human control, auditability, and replayability.

-------------------------------------------------
STEP 1 (safe): Patch Proposal Generator (NO APPLY)
-------------------------------------------------

Objectives:
- Let Lathe translate reasoning into concrete diffs.
- Maintain a strict separation between proposal and execution.

Actions:
- Extend lathe/agent.py with a patch proposal interface.
- Implement logic to:
  - Accept:
    - task description
    - WHY record
    - RAG evidence
  - Produce:
    - one or more unified diffs as text
    - clear explanation of intent per diff
- Enforce:
  - max files per proposal (default: 5)
  - no binary files
  - no deletions by default
- Add a CLI command:
  - `lathe propose "<task description>" --why <why_input>`
- Output:
  - proposed unified diff(s)
  - mapping from diff to evidence used
  - explicit assumptions and risks
- Do NOT write files.
- Do NOT update ledgers.
- Do NOT apply patches.

Deliverables:
- Updated lathe/agent.py (complete)
- CLI command wired into lathe/cli
- README.md updated with proposal workflow

-------------------------------------------------
STEP 2 (risky): Approval-Gated Apply Loop
-------------------------------------------------

Objectives:
- Close the loop from proposal to action safely.
- Ensure every applied change is intentional and documented.

Actions:
- Extend lathe apply command to support proposal input:
  - patch text piped from stdin OR
  - patch file generated by lathe propose
- Before applying:
  - display diff preview
  - show associated WHY goal and risks
  - require explicit user confirmation
- After applying:
  - update folder ledger automatically:
    - "Recent Work" on success
    - "Failed Attempts" on failure
  - reference:
    - WHY record
    - proposal summary
- Ensure:
  - proposal application remains optional
  - rejection does NOT update code
- Do NOT auto-run tests.
- Do NOT auto-retry failures.

Deliverables:
- Updated lathe/patch.py (complete)
- Updated CLI wiring
- README.md updated with approve/apply flow

-------------------------------------------------
STOP
-------------------------------------------------

After completing Step 2:
- STOP execution.
- Do NOT integrate:
  - OpenWebUI
  - auto-execution loops
  - background agents
  - databases
- Wait for the next instruction.